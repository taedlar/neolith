# LPC Program Compilation Memory Blocks

This document describes the `mem_block` data structure used by the LPC compiler during compilation. The compiler uses 24 separate memory areas to build up a program incrementally before assembling the final `program_t` structure.

## Overview

The `mem_block_t` structure (defined in [lib/lpc/compiler.h](../../lib/lpc/compiler.h)) manages dynamically growing memory regions:

```c
typedef struct mem_block_s {
    char *block;           // Pointer to allocated memory
    size_t current_size;   // Current used size in bytes
    size_t max_size;       // Maximum allocated size in bytes
} mem_block_t;
```

During compilation, 24 memory blocks are allocated (see `NUMAREAS`). Of these, the first 15 blocks (`NUMPAREAS`) are **permanent** and saved into the final `program_t` structure. The remaining 9 blocks are **temporary** and only used during compilation.

## Memory Block Areas

### Permanent Areas (Saved in Final Program)

These areas are copied into the final `program_t` structure in [epilog()](../../lib/lpc/compiler.c#L2108).

#### A_PROGRAM (0)
**Data Type**: `unsigned char[]` (bytecode instructions)  
**Description**: Executable LPC bytecode for the virtual stack machine. Contains the compiled instructions for all functions defined in this program.  
**Usage**: 
- Generated by [i_generate_node()](../../lib/lpc/program/icode.c) during parse tree traversal
- Switched to via `switch_to_block(A_PROGRAM)`
- Maximum size limited to 65535 bytes (16-bit addressing)
- Stored in `program_t.program`

**Implementation Notes**:
- Default compilation target (main code block)
- Line number tracking tied to this block (see [switch_to_line()](../../lib/lpc/program/icode.c#L309))
- Instructions added via `ins_byte()`, `ins_short()`, `ins_int()`, `ins_real()`

---

#### A_RUNTIME_FUNCTIONS (1)
**Data Type**: `runtime_function_u[]`  
**Description**: Runtime function dispatch table. Each entry describes how to call a function - either defined locally or inherited from a parent program.  
**Structure**:
```c
typedef union {
    runtime_defined_t def;    // num_arg, num_local, f_index
    runtime_inherited_t inh;  // offset (inherit index), index (function index in parent)
} runtime_function_u;
```
**Usage**:
- Indexed by `function_index_t` (full function index)
- One entry allocated per function via `allocate_in_mem_block()` in [define_new_function()](../../lib/lpc/compiler.c#L294)
- Distinguishes local vs inherited via `NAME_INHERITED` flag in `A_FUNCTION_FLAGS`
- Stored in `program_t.function_offsets`

**Implementation Notes**:
- Used at runtime by interpreter to dispatch function calls
- May be compressed via `A_RUNTIME_COMPRESSED` when `COMPRESS_FUNCTION_TABLES` enabled

---

#### A_COMPILER_FUNCTIONS (2)
**Data Type**: `compiler_function_t[]`  
**Description**: Function definition table for functions defined in this program (not inherited).  
**Structure**:
```c
struct compiler_function_s {
    char *name;                      // Shared string
    unsigned short type;             // Return type
    function_index_t runtime_index;  // Index into A_RUNTIME_FUNCTIONS
    function_address_t address;      // Bytecode address in A_PROGRAM
};
```
**Usage**:
- Indexed by `function_number_t` (definition-level index)
- Allocated when defining new function via [define_new_function()](../../lib/lpc/compiler.c#L1018)
- Sorted by name in [copy_and_sort_function_table()](../../lib/lpc/compiler.c) before saving
- Stored in `program_t.function_table`

**Implementation Notes**:
- Only contains functions **defined** at this inheritance level
- Name field must be freed during cleanup ([clean_parser()](../../lib/lpc/compiler.c#L2368))
- Referenced via `COMPILER_FUNC(n)` macro

---

#### A_RUNTIME_COMPRESSED (3)
**Data Type**: `compressed_offset_table_t`  
**Description**: Compressed mapping from full function indices to `runtime_function_u` entries. Used to save space in programs with deep inheritance hierarchies.  
**Structure**:
```c
typedef struct compressed_offset_table_s {
    function_index_t first_defined;
    function_index_t first_overload;
    unsigned short num_compressed;
    unsigned short num_deleted;
    unsigned char index[1];  // Variable-length array
} compressed_offset_table_t;
```
**Usage**:
- Only used when `COMPRESS_FUNCTION_TABLES` is defined
- Allocated in [compress_function_tables()](../../lib/lpc/compiler.c#L2051)
- Stored in `program_t.function_compressed`

**Implementation Notes**:
- Runtime lookup via `FIND_FUNC_ENTRY()` macro handles decompression
- Variable-length structure with `n_ov-1` extra bytes

---

#### A_FUNCTION_FLAGS (4)
**Data Type**: `function_flags_t[]` (unsigned short)  
**Description**: Array of flags for each function, describing modifiers and state.  
**Flags Include** (from [lib/lpc/program.h](../../lib/lpc/program.h)):
- `NAME_INHERITED` - Function is from inherited object
- `NAME_UNDEFINED` - Not yet defined
- `NAME_STRICT_TYPES` - Compiled with type checking
- `NAME_PROTOTYPE` - Only prototype seen
- `NAME_DEF_BY_INHERIT` - Definition exists in inherited object
- `NAME_ALIAS` - Refers to another function
- `NAME_TRUE_VARARGS` - True variable arguments
- `NAME_STATIC`, `NAME_PRIVATE`, `NAME_PROTECTED`, `NAME_PUBLIC` - Visibility
- `NAME_VARARGS` - Variable argument count (type checking)
- `NAME_NO_MASK` - Cannot be overridden

**Usage**:
- Indexed by `function_index_t` (full function index)
- Allocated alongside each function in [define_new_function()](../../lib/lpc/compiler.c#L295)
- Accessed via `FUNCTION_FLAGS(n)` macro
- Stored in `program_t.function_flags`

---

#### A_STRINGS (5)
**Data Type**: `char*[]` (array of shared string pointers)  
**Description**: Table of all string literals used in the program.  
**Usage**:
- Strings stored via [store_prog_string()](../../lib/lpc/compiler.c#L1197)
- Returns index used in bytecode instructions
- Freed via [free_prog_string()](../../lib/lpc/compiler.c#L1259)
- Referenced via `PROG_STRING(n)` macro
- Stored in `program_t.strings`

**Implementation Notes**:
- Hash table with chaining (see `string_idx[]`, `A_STRING_NEXT`)
- Reference counting via `A_STRING_REFS`
- Freed string indices reused via `freed_string` linked list
- All strings are **shared strings** (refcounted globally)

---

#### A_VAR_NAME (6)
**Data Type**: `char*[]` (array of shared string pointers)  
**Description**: Names of variables defined in this program.  
**Usage**:
- Allocated in [define_new_variable()](../../lib/lpc/compiler.c#L1123)
- One entry per variable defined (not inherited)
- Parallel to `A_VAR_TYPE`
- Stored in `program_t.variable_table`

---

#### A_VAR_TYPE (7)
**Data Type**: `unsigned short[]`  
**Description**: Type information for variables defined in this program.  
**Usage**:
- Allocated in [define_new_variable()](../../lib/lpc/compiler.c#L1126)
- One entry per variable (matches `A_VAR_NAME`)
- Types include modifiers: `TYPE_MOD_ARRAY`, `TYPE_MOD_CLASS`, visibility flags
- Stored in `program_t.variable_types`

---

#### A_LINENUMBERS (8)
**Data Type**: `unsigned char[]` (variable-length encoding)  
**Description**: Line number debug information. Encodes mapping from bytecode offset to source line.  
**Format**: Triplets of `[size, line_low, line_high]` where size is code bytes for that line.  
**Usage**:
- Generated by [switch_to_line()](../../lib/lpc/program/icode.c#L309)
- Only tracks `A_PROGRAM` block
- Large code spans (>255 bytes) split into multiple entries
- Stored separately via `DXALLOC()` in `program_t.line_info`

**Implementation Notes**:
- Can be swapped out to save memory at runtime
- Used for error reporting and debugging
- Not included in `align()` size calculation loop

---

#### A_FILE_INFO (9)
**Data Type**: `unsigned short[]`  
**Description**: File boundary markers for multi-file programs (via `#include`).  
**Format**: Array of file start line numbers.  
**Usage**:
- Updated via [save_file_info()](../../lib/lpc/compiler.c#L2572)
- Stored separately in `program_t.file_info` alongside line numbers

---

#### A_INHERITS (10)
**Data Type**: `inherit_t[]`  
**Description**: List of inherited programs.  
**Structure** (from [lib/lpc/program.h](../../lib/lpc/program.h)):
```c
typedef struct inherit_s {
    struct program_s *prog;              // Pointer to inherited program
    function_index_t function_index_offset;
    unsigned short variable_index_offset;
    unsigned short type_mod;             // Visibility modifiers
} inherit_t;
```
**Usage**:
- Allocated during `inherit` directive parsing ([grammar.y](../../lib/lpc/grammar.y#L239))
- One entry per inherited object
- Accessed via `INHERIT(n)` macro
- Stored in `program_t.inherit`

**Implementation Notes**:
- Programs are reference-counted; refs added in [epilog()](../../lib/lpc/compiler.c#L2316)
- Offsets used to translate inherited function/variable indices

---

#### A_CLASS_DEF (11)
**Data Type**: `class_def_t[]`  
**Description**: Definitions of LPC classes (user-defined data structures).  
**Structure** (from [lib/lpc/program.h](../../lib/lpc/program.h)):
```c
typedef struct class_def_s {
    unsigned short name;   // String index
    unsigned short type;   // Type modifiers
    unsigned short size;   // Number of members
    unsigned short index;  // Index into A_CLASS_MEMBER
} class_def_t;
```
**Usage**:
- Allocated during class definition ([grammar.y](../../lib/lpc/grammar.y#L414))
- Copied from inherited programs via [copy_structures()](../../lib/lpc/compiler.c#L421)
- Accessed via `CLASS(n)` macro
- Stored in `program_t.classes`

---

#### A_CLASS_MEMBER (12)
**Data Type**: `class_member_entry_t[]`  
**Description**: Member fields of LPC classes.  
**Structure** (from [lib/lpc/program.h](../../lib/lpc/program.h)):
```c
typedef struct class_member_entry_s {
    unsigned short name;  // String index
    unsigned short type;  // Field type
} class_member_entry_t;
```
**Usage**:
- Allocated during class definition ([grammar.y](../../lib/lpc/grammar.y#L419))
- Indexed via `class_def_t.index` from `A_CLASS_DEF`
- Stored in `program_t.class_members`

---

#### A_ARGUMENT_TYPES (13)
**Data Type**: `unsigned short[]` (lpc_type_t)  
**Description**: Type information for function arguments. Only saved if `#pragma save_types` is used.  
**Usage**:
- Allocated per function in [define_new_function()](../../lib/lpc/compiler.c#L1058)
- Index from `A_ARGUMENT_INDEX` points to start of this function's args
- Stored in `program_t.argument_types`
- Deleted if `!(pragmas & PRAGMA_SAVE_TYPES)` in [epilog()](../../lib/lpc/compiler.c#L2197)

**Implementation Notes**:
- Used for type checking during inheritance
- Significant memory savings when omitted

---

#### A_ARGUMENT_INDEX (14)
**Data Type**: `unsigned short[]`  
**Description**: Starting index into `A_ARGUMENT_TYPES` for each function.  
**Special Value**: `INDEX_START_NONE (65535)` means no type info.  
**Usage**:
- Allocated per function in [define_new_function()](../../lib/lpc/compiler.c#L1022)
- Indexed by `function_number_t`
- Stored in `program_t.type_start`
- Deleted if `A_ARGUMENT_TYPES` is empty

---

### Temporary Areas (Compilation Only)

These areas are **not** saved in the final program. They're freed in [epilog()](../../lib/lpc/compiler.c#L2314).

#### A_CASES (15)
**Data Type**: `parse_node_t*[]`  
**Description**: Temporary storage for `switch` statement case labels during parsing.  
**Usage**:
- Populated during switch parsing ([grammar.y](../../lib/lpc/grammar.y#L941))
- Used by [prepare_cases()](../../lib/lpc/compiler.c) to build switch tables
- Not saved in final program

---

#### A_STRING_NEXT (16)
**Data Type**: `short[]`  
**Description**: Hash chain links for string table. Each entry is the index of the next string in the hash collision chain.  
**Usage**:
- Parallel array to `A_STRINGS`
- Updated in [store_prog_string()](../../lib/lpc/compiler.c#L1251)
- Used for hash table collision resolution

---

#### A_STRING_REFS (17)
**Data Type**: `short[]`  
**Description**: Reference counts for program strings (separate from global shared string refs).  
**Usage**:
- Parallel array to `A_STRINGS`
- Incremented in [store_prog_string()](../../lib/lpc/compiler.c#L1209)
- Decremented in [free_prog_string()](../../lib/lpc/compiler.c#L1269)
- When count reaches 0, string index added to free list

---

#### A_INCLUDES (18)
**Data Type**: `char[]` (null-terminated strings)  
**Description**: List of included file names for binary save format.  
**Usage**:
- Populated by [add_program_file()](../../lib/lpc/compiler.c#L2585) via `#include`
- Used by [save_binary()](../../lib/lpc/program/binaries.c) when saving compiled programs
- Not saved in memory-resident program

---

#### A_PATCH (19)
**Data Type**: `short[]`  
**Description**: Offsets needing patching during binary save. Used for relocating string table references.  
**Usage**:
- Populated during switch string generation ([icode.c](../../lib/lpc/program/icode.c#L658))
- Passed to [save_binary()](../../lib/lpc/compiler.c#L2307)
- Not saved in final program

---

#### A_INITIALIZER (20)
**Data Type**: `unsigned char[]` (bytecode)  
**Description**: Bytecode for global variable initialization. Compiled into the `__INIT` function.  
**Usage**:
- Switched to during variable initialization code generation ([grammar.y](../../lib/lpc/grammar.y#L250))
- Appended to `A_PROGRAM` at end of compilation ([epilog()](../../lib/lpc/compiler.c#L2140))
- Creates implicit `__INIT()` function if non-empty

**Implementation Notes**:
- For compatibility, a jump to `__INIT` is placed at program address 0
- Function marked `NAME_PRIVATE` to prevent external calls

---

#### A_FUNCTIONALS (21)
**Data Type**: Currently unused  
**Description**: Reserved area, not currently used in implementation.  
**Implementation Notes**:
- No grep matches found in codebase
- May be vestigial from earlier compiler versions

---

#### A_FUNCTION_DEFS (22)
**Data Type**: `compiler_temp_t[]`  
**Description**: Temporary function metadata during compilation. Tracks inheritance relationships and aliases.  
**Structure**:
```c
typedef struct compiler_temp_s {
    struct program_s *prog;  // Non-NULL if inherited
    union {
        compiler_function_t *func;  // If inherited
        function_index_t index;     // If local (index into A_COMPILER_FUNCTIONS)
    } u;
    unsigned short alias_for;  // Overload tracking
} compiler_temp_t;
```
**Usage**:
- Allocated per function in [define_new_function()](../../lib/lpc/compiler.c#L296)
- Indexed by `function_index_t` (full index)
- Accessed via `FUNCTION_TEMP(n)` macro
- Resolves inheritance via `FUNCTION_PROG(n)`, `FUNCTION_DEF(n)` macros

**Implementation Notes**:
- Critical for distinguishing local vs inherited functions during compilation
- Not saved (only `A_COMPILER_FUNCTIONS` is saved)

---

#### A_VAR_TEMP (23)
**Data Type**: `variable_t[]`  
**Description**: Temporary variable tracking during compilation, including inherited variables.  
**Structure**:
```c
typedef struct variable_s {
    char *name;          // Shared string
    unsigned short type; // Type with modifiers
} variable_t;
```
**Usage**:
- Allocated in [define_new_variable()](../../lib/lpc/compiler.c#L1104)
- Includes **both** defined and inherited variables
- Accessed via `VAR_TEMP(n)` macro
- Used to calculate `program_t.num_variables_total`

**Implementation Notes**:
- Total count distinct from `num_variables_defined` (only from `A_VAR_NAME`)
- Not saved directly; only defined variables go into final program

---

## Lifecycle

### Initialization
In [prolog()](../../lib/lpc/compiler.c#L2337):
```c
for (i = 0; i < NUMAREAS; i++) {
    mem_block[i].block = DXALLOC(START_BLOCK_SIZE, TAG_COMPILER, "prolog: 2");
    mem_block[i].current_size = 0;
    mem_block[i].max_size = START_BLOCK_SIZE;  // 4096 bytes initially
}
```

### Dynamic Growth
Blocks grow automatically via `realloc_mem_block()`:
```c
while (size > m->max_size) {
    m->max_size <<= 1;  // Double the size
    m->block = DREALLOC(m->block, m->max_size, ...);
}
```

### Finalization
In [epilog()](../../lib/lpc/compiler.c#L2108):
1. Calculate total size needed for permanent areas (0-14)
2. Allocate single contiguous block for `program_t`
3. Copy permanent areas via `copy_in()` with alignment
4. Free all temporary blocks

### Cleanup
In [clean_parser()](../../lib/lpc/compiler.c#L2365) (on errors):
1. Free shared strings in `A_STRINGS`, `A_VAR_NAME`, `A_COMPILER_FUNCTIONS`
2. Free all block memory
3. Clean up local variables and identifiers

---

## Block Switching

The compiler maintains a **current block** pointer for code generation:

```c
void switch_to_block(int block) {
    UPDATE_PROGRAM_SIZE;  // Save current block size
    prog_code = mem_block[block].block + mem_block[block].current_size;
    prog_code_max = mem_block[block].block + mem_block[block].max_size;
    current_block = block;
}
```

**Primary Use**: Switching between `A_PROGRAM` (main code) and `A_INITIALIZER` (variable initialization).

---

## Memory Alignment

The `align()` macro ensures proper struct alignment:
```c
#define align(x) (((x) + 3) & ~3)  // 4-byte alignment (32-bit)
// OR on 64-bit platforms:
#define align(x) (((x) + 7) & ~7)  // 8-byte alignment
```

Applied when calculating final program size to prevent misaligned struct accesses.

---

## Helper Macros

Defined in [compiler.h](../../lib/lpc/compiler.h):

| Macro | Purpose | Area Used |
|-------|---------|-----------|
| `FUNCTION_RENTRY(n)` | Get runtime function entry | A_RUNTIME_FUNCTIONS |
| `COMPILER_FUNC(n)` | Get compiler function definition | A_COMPILER_FUNCTIONS |
| `FUNCTION_FLAGS(n)` | Get function flags | A_FUNCTION_FLAGS |
| `FUNCTION_TEMP(n)` | Get temp function metadata | A_FUNCTION_DEFS |
| `INHERIT(n)` | Get inherit entry | A_INHERITS |
| `VAR_TEMP(n)` | Get temp variable entry | A_VAR_TEMP |
| `PROG_STRING(n)` | Get string from table | A_STRINGS |
| `CLASS(n)` | Get class definition | A_CLASS_DEF |

---

## Size Calculations

From [epilog()](../../lib/lpc/compiler.c#L2108):

```c
size = align(sizeof(program_t));
for (i = 0; i < NUMPAREAS; i++)
    if (i != A_LINENUMBERS && i != A_FILE_INFO)  // Allocated separately
        size += align(mem_block[i].current_size);
```

**Line/File Info**: Allocated separately as a single block (not counted in main size loop) with format ([epilog() line 2228](../../lib/lpc/compiler.c#L2228)):
```
[total_size:short][offset_to_line_info:short][file_info_blob][line_info_blob]
```

---

## Binary Serialization

Neolith supports saving compiled programs to binary files (`.b` extension) to accelerate startup on subsequent driver runs. This avoids re-parsing and re-compiling LPC source code.

### Activation

Enabled via `#pragma save_binary` in LPC source and `__SAVE_BINARIES_DIR__` runtime config. The driver checks `valid_save_binary()` apply in master object for permission.

### Binary File Format

Binary files use the `.b` extension (source files use `.c`). Structure:

```
[Preamble]
  - Magic ID: "NEOL" (4 bytes)
  - Driver ID: 0x20251029 (incremented when driver changes)
  - Config ID: simul_efun file mtime (ensures consistency)

[Include Files List]
  - Length (short)
  - Null-terminated filenames (for timestamp validation)

[Program Name]
  - Length (short)
  - Name string (validation against expected file)

[Program Structure]
  - Total size (int)
  - Complete program_t struct (with relative pointers)

[Inherited Program Names]
  - For each inherit: length (short) + name (char[])

[String Table]
  - For each string: length (short) + string data (char[])
  - Shared strings are recreated on load via make_shared_string()

[Variable Names]
  - For each variable: length (short) + name (char[])

[Function Names]
  - For each function: length (short) + name (char[])

[Line Number Information]
  - Length (short)
  - Combined file_info + line_info blob

[Patches]
  - Length (short)
  - Array of offsets needing pointer fixups (from A_PATCH)
```

### Pointer Serialization

The `program_t` structure contains many internal pointers that must be converted for disk storage:

**Relative Pointers** ([locate_out()](../../lib/lpc/program/binaries.c#L878)):
- Before saving, absolute pointers converted to offsets from `program_t` base
- Calculation: `ptr_field = (char*)ptr_field - (char*)prog`
- Applied to: `program`, `function_table`, `function_flags`, `function_offsets`, `function_compressed`, `strings`, `variable_table`, `variable_types`, `inherit`, `classes`, `class_members`, `argument_types`, `type_start`

**Absolute Pointers** ([locate_in()](../../lib/lpc/program/binaries.c#L911)):
- After loading, offsets converted back to absolute pointers
- Calculation: `ptr_field = (char*)prog + (intptr_t)ptr_field`
- Same fields as `locate_out()`

**Special Handling - Switch Tables** ([patch_out()](../../lib/lpc/program/binaries.c#L727)/[patch_in()](../../lib/lpc/program/binaries.c#L778)):
- String switch statements embed string pointers in bytecode
- **Save**: Replace string pointers with string table indices (via `store_prog_string()`)
- **Load**: Replace indices with actual string pointers, then re-sort for binary search
- Patch locations tracked in `A_PATCH` during compilation

### Save Process

In [save_binary()](../../lib/lpc/program/binaries.c#L41):

1. **Validation**:
   - Check `__SAVE_BINARIES_DIR__` configured
   - Call `valid_save_binary()` apply (if driver initialized)
   - Verify size limits (< 65535 bytes for size fields)

2. **File Preparation**:
   - Convert `.c` extension to `.b`
   - Create intermediate directories via [crdir_fopen()](../../lib/lpc/program/binaries.c#L832)

3. **Write Preamble**: Magic ID, driver ID, config ID

4. **Write Include List**: From `A_INCLUDES` mem_block (for timestamp validation)

5. **Pointer Conversion**:
   - Copy program to temporary buffer
   - Call `locate_out()` to convert absolute→relative pointers
   - Call `patch_out()` to convert string pointers→indices in switch tables

6. **Write Program**: Entire `program_t` structure (total_size bytes)

7. **Write String Data**:
   - Inherited program names (without full objects)
   - String table (length-prefixed strings)
   - Variable names
   - Function names (sorted alphabetically except `#`-prefixed stay last)
   - Line number info

8. **Write Patches**: Array of offsets from `A_PATCH`

### Load Process

In [int_load_binary()](../../lib/lpc/program/binaries.c#L345):

1. **File Lookup**:
   - Check `__SAVE_BINARIES_DIR__` configured
   - Convert `.c` extension to `.b`
   - Return `OUT_OF_DATE` (0) if file doesn't exist

2. **Validation**:
   - Read and verify magic ID, driver ID, config ID
   - Check source file modification time (binary must be newer)
   - Check all include file modification times
   - Check inherited binary modification times (if they exist)
   - Program name must match expected name

3. **Read Program Structure**:
   - Read total size and allocate via `DXALLOC()`
   - Read entire `program_t` block
   - Call `locate_in()` to convert relative→absolute pointers
   - Create shared string for program name

4. **Inherit Resolution**:
   - Read inherited program names
   - Look up objects via `find_object_by_name()`
   - If not found, set `inherit_file` global and return 0 (triggers recursive load)
   - Assign `p->inherit[i].prog` pointers

5. **String Reconstruction**:
   - Read string table and call `make_shared_string()` for each
   - Read variable names (as shared strings)
   - Read function names (as shared strings)

6. **Function Table Sort**:
   - Call [sort_function_table()](../../lib/lpc/program/binaries.c#L222) to restore alphabetical order
   - Updates `function_offsets[].def.f_index` references to match new order
   - Preserves `#`-prefixed functions at end

7. **Line Number Restoration**:
   - Read combined file_info + line_info block
   - Set `p->line_info` to offset within `p->file_info`

8. **Pointer Fixups**:
   - Read patch list
   - Call `patch_in()` to convert string indices→pointers in switch tables
   - Re-sort switch tables for binary search

9. **Finalization**:
   - Assign unique `id_number` via `get_id_number()`
   - Update global statistics (`total_prog_block_size`, `total_num_prog_blocks`)
   - Call `reference_prog()` to increment refcounts (program + all inherits)

### Timestamp Validation

Binary loading fails (returns `OUT_OF_DATE`) if:
- Source file (`.c`) is newer than binary (`.b`)
- Any `#include` file is newer than binary
- Any inherited source file is newer than binary
- Any inherited binary file is newer than current binary (indicates recompilation needed)
- Driver ID or config ID mismatch (driver/simul_efun changed)

This ensures binaries are **always consistent** with current source code state.

### String Switch Patching

String switch statements require special handling because they embed **runtime string pointers** in bytecode:

**Problem**: Shared string addresses vary between driver runs, making saved pointers invalid.

**Solution**:
1. During save, `patch_out()` converts pointers to string table **indices** (stable across runs)
2. During load, `patch_in()` converts indices back to **current runtime pointers**
3. After conversion, switch table is re-sorted (required for binary search in `f_switch()`)

**Patch Tracking**: The `A_PATCH` mem_block stores bytecode offsets of all switch instructions during compilation. These offsets are saved with the binary and used during `patch_in()`.

### Function Table Sorting

Function names must be sorted for binary search during function lookups:

- **During Save**: Already sorted in [epilog()](../../lib/lpc/compiler.c#L2254) via `copy_and_sort_function_table()`
- **During Load**: Re-sorted via `sort_function_table()` because string pointers change between runs
- **Sort Order**: Alphabetical by pointer address (not string content), except `#`-prefixed functions last
- **Index Updates**: After sorting, all `function_offsets[i].def.f_index` references updated to new positions

This preserves the invariant that function table is always sorted by name pointer for efficient binary search.

### Configuration

**Runtime Config** (`neolith.conf`):
```
__SAVE_BINARIES_DIR__ = "/path/to/binary/cache"
```

**Source Code**:
```lpc
#pragma save_binary
```

**Master Object Apply**:
```lpc
int valid_save_binary(string file) {
    // Return 1 to allow, 0 to deny
    return 1;
}
```

### Error Handling

If binary loading fails for any reason (validation, corruption, version mismatch), the driver:
1. Returns `OUT_OF_DATE` (0) from `int_load_binary()`
2. Falls back to normal compilation via `compile_file()`
3. May trigger recursive loading of inherited files (via `inherit_file` global)

### Implementation Files

- **Save/Load**: [lib/lpc/program/binaries.c](../../lib/lpc/program/binaries.c)
- **Initialization**: [init_binaries()](../../lib/lpc/program/binaries.c#L677) - called during driver startup
- **Interface**: [lib/lpc/program/binaries.h](../../lib/lpc/program/binaries.h)

---

## References

- **Header**: [lib/lpc/compiler.h](../../lib/lpc/compiler.h)
- **Main Implementation**: [lib/lpc/compiler.c](../../lib/lpc/compiler.c)
- **Code Generation**: [lib/lpc/program/icode.c](../../lib/lpc/program/icode.c)
- **Binary Serialization**: [lib/lpc/program/binaries.c](../../lib/lpc/program/binaries.c)
- **Parse Trees**: [lib/lpc/program/parse_trees.h](../../lib/lpc/program/parse_trees.h)
- **Program Structure**: [lib/lpc/program.h](../../lib/lpc/program.h)
